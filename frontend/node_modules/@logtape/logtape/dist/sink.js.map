{"version":3,"file":"sink.js","names":["sink: Sink","filter: FilterLike","record: LogRecord","stream: WritableStream","options: StreamSinkOptions","sink: Sink & AsyncDisposable","buffer: LogRecord[]","flushTimer: ReturnType<typeof setInterval> | null","activeFlush: Promise<void> | null","nonBlockingSink: Sink & AsyncDisposable","options: ConsoleSinkOptions","levelMap: Record<LogLevel, ConsoleMethod>","nonBlockingSink: Sink & Disposable","asyncSink: AsyncSink"],"sources":["../sink.ts"],"sourcesContent":["import { type FilterLike, toFilter } from \"./filter.ts\";\nimport {\n  type ConsoleFormatter,\n  defaultConsoleFormatter,\n  defaultTextFormatter,\n  type TextFormatter,\n} from \"./formatter.ts\";\nimport type { LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\n\n/**\n * A sink is a function that accepts a log record and prints it somewhere.\n * Thrown exceptions will be suppressed and then logged to the meta logger,\n * a {@link Logger} with the category `[\"logtape\", \"meta\"]`.  (In that case,\n * the meta log record will not be passed to the sink to avoid infinite\n * recursion.)\n *\n * @param record The log record to sink.\n */\nexport type Sink = (record: LogRecord) => void;\n\n/**\n * An async sink is a function that accepts a log record and asynchronously\n * processes it. This type is used with {@link fromAsyncSink} to create\n * a regular sink that properly handles asynchronous operations.\n *\n * @param record The log record to process asynchronously.\n * @returns A promise that resolves when the record has been processed.\n * @since 1.0.0\n */\nexport type AsyncSink = (record: LogRecord) => Promise<void>;\n\n/**\n * Turns a sink into a filtered sink.  The returned sink only logs records that\n * pass the filter.\n *\n * @example Filter a console sink to only log records with the info level\n * ```typescript\n * const sink = withFilter(getConsoleSink(), \"info\");\n * ```\n *\n * @param sink A sink to be filtered.\n * @param filter A filter to apply to the sink.  It can be either a filter\n *               function or a {@link LogLevel} string.\n * @returns A sink that only logs records that pass the filter.\n */\nexport function withFilter(sink: Sink, filter: FilterLike): Sink {\n  const filterFunc = toFilter(filter);\n  return (record: LogRecord) => {\n    if (filterFunc(record)) sink(record);\n  };\n}\n\n/**\n * Options for the {@link getStreamSink} function.\n */\nexport interface StreamSinkOptions {\n  /**\n   * The text formatter to use.  Defaults to {@link defaultTextFormatter}.\n   */\n  formatter?: TextFormatter;\n\n  /**\n   * The text encoder to use.  Defaults to an instance of {@link TextEncoder}.\n   */\n  encoder?: { encode(text: string): Uint8Array };\n\n  /**\n   * Enable non-blocking mode with optional buffer configuration.\n   * When enabled, log records are buffered and flushed in the background.\n   *\n   * @example Simple non-blocking mode\n   * ```typescript\n   * getStreamSink(stream, { nonBlocking: true });\n   * ```\n   *\n   * @example Custom buffer configuration\n   * ```typescript\n   * getStreamSink(stream, {\n   *   nonBlocking: {\n   *     bufferSize: 1000,\n   *     flushInterval: 50\n   *   }\n   * });\n   * ```\n   *\n   * @default `false`\n   * @since 1.0.0\n   */\n  nonBlocking?: boolean | {\n    /**\n     * Maximum number of records to buffer before flushing.\n     * @default `100`\n     */\n    bufferSize?: number;\n\n    /**\n     * Interval in milliseconds between automatic flushes.\n     * @default `100`\n     */\n    flushInterval?: number;\n  };\n}\n\n/**\n * A factory that returns a sink that writes to a {@link WritableStream}.\n *\n * Note that the `stream` is of Web Streams API, which is different from\n * Node.js streams.  You can convert a Node.js stream to a Web Streams API\n * stream using [`stream.Writable.toWeb()`] method.\n *\n * [`stream.Writable.toWeb()`]: https://nodejs.org/api/stream.html#streamwritabletowebstreamwritable\n *\n * @example Sink to the standard error in Deno\n * ```typescript\n * const stderrSink = getStreamSink(Deno.stderr.writable);\n * ```\n *\n * @example Sink to the standard error in Node.js\n * ```typescript\n * import stream from \"node:stream\";\n * const stderrSink = getStreamSink(stream.Writable.toWeb(process.stderr));\n * ```\n *\n * @param stream The stream to write to.\n * @param options The options for the sink.\n * @returns A sink that writes to the stream.\n */\nexport function getStreamSink(\n  stream: WritableStream,\n  options: StreamSinkOptions = {},\n): Sink & AsyncDisposable {\n  const formatter = options.formatter ?? defaultTextFormatter;\n  const encoder = options.encoder ?? new TextEncoder();\n  const writer = stream.getWriter();\n\n  if (!options.nonBlocking) {\n    let lastPromise = Promise.resolve();\n    const sink: Sink & AsyncDisposable = (record: LogRecord) => {\n      const bytes = encoder.encode(formatter(record));\n      lastPromise = lastPromise\n        .then(() => writer.ready)\n        .then(() => writer.write(bytes));\n    };\n    sink[Symbol.asyncDispose] = async () => {\n      await lastPromise;\n      await writer.close();\n    };\n    return sink;\n  }\n\n  // Non-blocking mode implementation\n  const nonBlockingConfig = options.nonBlocking === true\n    ? {}\n    : options.nonBlocking;\n  const bufferSize = nonBlockingConfig.bufferSize ?? 100;\n  const flushInterval = nonBlockingConfig.flushInterval ?? 100;\n\n  const buffer: LogRecord[] = [];\n  let flushTimer: ReturnType<typeof setInterval> | null = null;\n  let disposed = false;\n  let activeFlush: Promise<void> | null = null;\n  const maxBufferSize = bufferSize * 2; // Overflow protection\n\n  async function flush(): Promise<void> {\n    if (buffer.length === 0) return;\n\n    const records = buffer.splice(0);\n    for (const record of records) {\n      try {\n        const bytes = encoder.encode(formatter(record));\n        await writer.ready;\n        await writer.write(bytes);\n      } catch {\n        // Silently ignore errors in non-blocking mode to avoid disrupting the application\n      }\n    }\n  }\n\n  function scheduleFlush(): void {\n    if (activeFlush) return;\n\n    activeFlush = flush().finally(() => {\n      activeFlush = null;\n    });\n  }\n\n  function startFlushTimer(): void {\n    if (flushTimer !== null || disposed) return;\n\n    flushTimer = setInterval(() => {\n      scheduleFlush();\n    }, flushInterval);\n  }\n\n  const nonBlockingSink: Sink & AsyncDisposable = (record: LogRecord) => {\n    if (disposed) return;\n\n    // Buffer overflow protection: drop oldest records if buffer is too large\n    if (buffer.length >= maxBufferSize) {\n      buffer.shift(); // Remove oldest record\n    }\n\n    buffer.push(record);\n\n    if (buffer.length >= bufferSize) {\n      scheduleFlush();\n    } else if (flushTimer === null) {\n      startFlushTimer();\n    }\n  };\n\n  nonBlockingSink[Symbol.asyncDispose] = async () => {\n    disposed = true;\n    if (flushTimer !== null) {\n      clearInterval(flushTimer);\n      flushTimer = null;\n    }\n    await flush();\n    try {\n      await writer.close();\n    } catch {\n      // Writer might already be closed or errored\n    }\n  };\n\n  return nonBlockingSink;\n}\n\ntype ConsoleMethod = \"debug\" | \"info\" | \"log\" | \"warn\" | \"error\";\n\n/**\n * Options for the {@link getConsoleSink} function.\n */\nexport interface ConsoleSinkOptions {\n  /**\n   * The console formatter or text formatter to use.\n   * Defaults to {@link defaultConsoleFormatter}.\n   */\n  formatter?: ConsoleFormatter | TextFormatter;\n\n  /**\n   * The mapping from log levels to console methods.  Defaults to:\n   *\n   * ```typescript\n   * {\n   *   trace: \"trace\",\n   *   debug: \"debug\",\n   *   info: \"info\",\n   *   warning: \"warn\",\n   *   error: \"error\",\n   *   fatal: \"error\",\n   * }\n   * ```\n   * @since 0.9.0\n   */\n  levelMap?: Record<LogLevel, ConsoleMethod>;\n\n  /**\n   * The console to log to.  Defaults to {@link console}.\n   */\n  console?: Console;\n\n  /**\n   * Enable non-blocking mode with optional buffer configuration.\n   * When enabled, log records are buffered and flushed in the background.\n   *\n   * @example Simple non-blocking mode\n   * ```typescript\n   * getConsoleSink({ nonBlocking: true });\n   * ```\n   *\n   * @example Custom buffer configuration\n   * ```typescript\n   * getConsoleSink({\n   *   nonBlocking: {\n   *     bufferSize: 1000,\n   *     flushInterval: 50\n   *   }\n   * });\n   * ```\n   *\n   * @default `false`\n   * @since 1.0.0\n   */\n  nonBlocking?: boolean | {\n    /**\n     * Maximum number of records to buffer before flushing.\n     * @default `100`\n     */\n    bufferSize?: number;\n\n    /**\n     * Interval in milliseconds between automatic flushes.\n     * @default `100`\n     */\n    flushInterval?: number;\n  };\n}\n\n/**\n * A console sink factory that returns a sink that logs to the console.\n *\n * @param options The options for the sink.\n * @returns A sink that logs to the console. If `nonBlocking` is enabled,\n *          returns a sink that also implements {@link Disposable}.\n */\nexport function getConsoleSink(\n  options: ConsoleSinkOptions = {},\n): Sink | (Sink & Disposable) {\n  const formatter = options.formatter ?? defaultConsoleFormatter;\n  const levelMap: Record<LogLevel, ConsoleMethod> = {\n    trace: \"debug\",\n    debug: \"debug\",\n    info: \"info\",\n    warning: \"warn\",\n    error: \"error\",\n    fatal: \"error\",\n    ...(options.levelMap ?? {}),\n  };\n  const console = options.console ?? globalThis.console;\n\n  const baseSink = (record: LogRecord) => {\n    const args = formatter(record);\n    const method = levelMap[record.level];\n    if (method === undefined) {\n      throw new TypeError(`Invalid log level: ${record.level}.`);\n    }\n    if (typeof args === \"string\") {\n      const msg = args.replace(/\\r?\\n$/, \"\");\n      console[method](msg);\n    } else {\n      console[method](...args);\n    }\n  };\n\n  if (!options.nonBlocking) {\n    return baseSink;\n  }\n\n  // Non-blocking mode implementation\n  const nonBlockingConfig = options.nonBlocking === true\n    ? {}\n    : options.nonBlocking;\n  const bufferSize = nonBlockingConfig.bufferSize ?? 100;\n  const flushInterval = nonBlockingConfig.flushInterval ?? 100;\n\n  const buffer: LogRecord[] = [];\n  let flushTimer: ReturnType<typeof setInterval> | null = null;\n  let disposed = false;\n  let flushScheduled = false;\n  const maxBufferSize = bufferSize * 2; // Overflow protection\n\n  function flush(): void {\n    if (buffer.length === 0) return;\n\n    const records = buffer.splice(0);\n    for (const record of records) {\n      try {\n        baseSink(record);\n      } catch {\n        // Silently ignore errors in non-blocking mode to avoid disrupting the application\n      }\n    }\n  }\n\n  function scheduleFlush(): void {\n    if (flushScheduled) return;\n\n    flushScheduled = true;\n    setTimeout(() => {\n      flushScheduled = false;\n      flush();\n    }, 0);\n  }\n\n  function startFlushTimer(): void {\n    if (flushTimer !== null || disposed) return;\n\n    flushTimer = setInterval(() => {\n      flush();\n    }, flushInterval);\n  }\n\n  const nonBlockingSink: Sink & Disposable = (record: LogRecord) => {\n    if (disposed) return;\n\n    // Buffer overflow protection: drop oldest records if buffer is too large\n    if (buffer.length >= maxBufferSize) {\n      buffer.shift(); // Remove oldest record\n    }\n\n    buffer.push(record);\n\n    if (buffer.length >= bufferSize) {\n      scheduleFlush();\n    } else if (flushTimer === null) {\n      startFlushTimer();\n    }\n  };\n\n  nonBlockingSink[Symbol.dispose] = () => {\n    disposed = true;\n    if (flushTimer !== null) {\n      clearInterval(flushTimer);\n      flushTimer = null;\n    }\n    flush();\n  };\n\n  return nonBlockingSink;\n}\n\n/**\n * Converts an async sink into a regular sink with proper async handling.\n * The returned sink chains async operations to ensure proper ordering and\n * implements AsyncDisposable to wait for all pending operations on disposal.\n *\n * @example Create a sink that asynchronously posts to a webhook\n * ```typescript\n * const asyncSink: AsyncSink = async (record) => {\n *   await fetch(\"https://example.com/logs\", {\n *     method: \"POST\",\n *     body: JSON.stringify(record),\n *   });\n * };\n * const sink = fromAsyncSink(asyncSink);\n * ```\n *\n * @param asyncSink The async sink function to convert.\n * @returns A sink that properly handles async operations and disposal.\n * @since 1.0.0\n */\nexport function fromAsyncSink(asyncSink: AsyncSink): Sink & AsyncDisposable {\n  let lastPromise = Promise.resolve();\n  const sink: Sink & AsyncDisposable = (record: LogRecord) => {\n    lastPromise = lastPromise\n      .then(() => asyncSink(record))\n      .catch(() => {\n        // Errors are handled by the sink infrastructure\n      });\n  };\n  sink[Symbol.asyncDispose] = async () => {\n    await lastPromise;\n  };\n  return sink;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AA8CA,SAAgB,WAAWA,MAAYC,QAA0B;CAC/D,MAAM,aAAa,SAAS,OAAO;AACnC,QAAO,CAACC,WAAsB;AAC5B,MAAI,WAAW,OAAO,CAAE,MAAK,OAAO;CACrC;AACF;;;;;;;;;;;;;;;;;;;;;;;;;AA6ED,SAAgB,cACdC,QACAC,UAA6B,CAAE,GACP;CACxB,MAAM,YAAY,QAAQ,aAAa;CACvC,MAAM,UAAU,QAAQ,WAAW,IAAI;CACvC,MAAM,SAAS,OAAO,WAAW;AAEjC,MAAK,QAAQ,aAAa;EACxB,IAAI,cAAc,QAAQ,SAAS;EACnC,MAAMC,OAA+B,CAACH,WAAsB;GAC1D,MAAM,QAAQ,QAAQ,OAAO,UAAU,OAAO,CAAC;AAC/C,iBAAc,YACX,KAAK,MAAM,OAAO,MAAM,CACxB,KAAK,MAAM,OAAO,MAAM,MAAM,CAAC;EACnC;AACD,OAAK,OAAO,gBAAgB,YAAY;AACtC,SAAM;AACN,SAAM,OAAO,OAAO;EACrB;AACD,SAAO;CACR;CAGD,MAAM,oBAAoB,QAAQ,gBAAgB,OAC9C,CAAE,IACF,QAAQ;CACZ,MAAM,aAAa,kBAAkB,cAAc;CACnD,MAAM,gBAAgB,kBAAkB,iBAAiB;CAEzD,MAAMI,SAAsB,CAAE;CAC9B,IAAIC,aAAoD;CACxD,IAAI,WAAW;CACf,IAAIC,cAAoC;CACxC,MAAM,gBAAgB,aAAa;CAEnC,eAAe,QAAuB;AACpC,MAAI,OAAO,WAAW,EAAG;EAEzB,MAAM,UAAU,OAAO,OAAO,EAAE;AAChC,OAAK,MAAM,UAAU,QACnB,KAAI;GACF,MAAM,QAAQ,QAAQ,OAAO,UAAU,OAAO,CAAC;AAC/C,SAAM,OAAO;AACb,SAAM,OAAO,MAAM,MAAM;EAC1B,QAAO,CAEP;CAEJ;CAED,SAAS,gBAAsB;AAC7B,MAAI,YAAa;AAEjB,gBAAc,OAAO,CAAC,QAAQ,MAAM;AAClC,iBAAc;EACf,EAAC;CACH;CAED,SAAS,kBAAwB;AAC/B,MAAI,eAAe,QAAQ,SAAU;AAErC,eAAa,YAAY,MAAM;AAC7B,kBAAe;EAChB,GAAE,cAAc;CAClB;CAED,MAAMC,kBAA0C,CAACP,WAAsB;AACrE,MAAI,SAAU;AAGd,MAAI,OAAO,UAAU,cACnB,QAAO,OAAO;AAGhB,SAAO,KAAK,OAAO;AAEnB,MAAI,OAAO,UAAU,WACnB,gBAAe;WACN,eAAe,KACxB,kBAAiB;CAEpB;AAED,iBAAgB,OAAO,gBAAgB,YAAY;AACjD,aAAW;AACX,MAAI,eAAe,MAAM;AACvB,iBAAc,WAAW;AACzB,gBAAa;EACd;AACD,QAAM,OAAO;AACb,MAAI;AACF,SAAM,OAAO,OAAO;EACrB,QAAO,CAEP;CACF;AAED,QAAO;AACR;;;;;;;;AAgFD,SAAgB,eACdQ,UAA8B,CAAE,GACJ;CAC5B,MAAM,YAAY,QAAQ,aAAa;CACvC,MAAMC,WAA4C;EAChD,OAAO;EACP,OAAO;EACP,MAAM;EACN,SAAS;EACT,OAAO;EACP,OAAO;EACP,GAAI,QAAQ,YAAY,CAAE;CAC3B;CACD,MAAM,UAAU,QAAQ,WAAW,WAAW;CAE9C,MAAM,WAAW,CAACT,WAAsB;EACtC,MAAM,OAAO,UAAU,OAAO;EAC9B,MAAM,SAAS,SAAS,OAAO;AAC/B,MAAI,kBACF,OAAM,IAAI,WAAW,qBAAqB,OAAO,MAAM;AAEzD,aAAW,SAAS,UAAU;GAC5B,MAAM,MAAM,KAAK,QAAQ,UAAU,GAAG;AACtC,WAAQ,QAAQ,IAAI;EACrB,MACC,SAAQ,QAAQ,GAAG,KAAK;CAE3B;AAED,MAAK,QAAQ,YACX,QAAO;CAIT,MAAM,oBAAoB,QAAQ,gBAAgB,OAC9C,CAAE,IACF,QAAQ;CACZ,MAAM,aAAa,kBAAkB,cAAc;CACnD,MAAM,gBAAgB,kBAAkB,iBAAiB;CAEzD,MAAMI,SAAsB,CAAE;CAC9B,IAAIC,aAAoD;CACxD,IAAI,WAAW;CACf,IAAI,iBAAiB;CACrB,MAAM,gBAAgB,aAAa;CAEnC,SAAS,QAAc;AACrB,MAAI,OAAO,WAAW,EAAG;EAEzB,MAAM,UAAU,OAAO,OAAO,EAAE;AAChC,OAAK,MAAM,UAAU,QACnB,KAAI;AACF,YAAS,OAAO;EACjB,QAAO,CAEP;CAEJ;CAED,SAAS,gBAAsB;AAC7B,MAAI,eAAgB;AAEpB,mBAAiB;AACjB,aAAW,MAAM;AACf,oBAAiB;AACjB,UAAO;EACR,GAAE,EAAE;CACN;CAED,SAAS,kBAAwB;AAC/B,MAAI,eAAe,QAAQ,SAAU;AAErC,eAAa,YAAY,MAAM;AAC7B,UAAO;EACR,GAAE,cAAc;CAClB;CAED,MAAMK,kBAAqC,CAACV,WAAsB;AAChE,MAAI,SAAU;AAGd,MAAI,OAAO,UAAU,cACnB,QAAO,OAAO;AAGhB,SAAO,KAAK,OAAO;AAEnB,MAAI,OAAO,UAAU,WACnB,gBAAe;WACN,eAAe,KACxB,kBAAiB;CAEpB;AAED,iBAAgB,OAAO,WAAW,MAAM;AACtC,aAAW;AACX,MAAI,eAAe,MAAM;AACvB,iBAAc,WAAW;AACzB,gBAAa;EACd;AACD,SAAO;CACR;AAED,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;AAsBD,SAAgB,cAAcW,WAA8C;CAC1E,IAAI,cAAc,QAAQ,SAAS;CACnC,MAAMR,OAA+B,CAACH,WAAsB;AAC1D,gBAAc,YACX,KAAK,MAAM,UAAU,OAAO,CAAC,CAC7B,MAAM,MAAM,CAEZ,EAAC;CACL;AACD,MAAK,OAAO,gBAAgB,YAAY;AACtC,QAAM;CACP;AACD,QAAO;AACR"}