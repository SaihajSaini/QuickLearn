var z = Object.defineProperty;
var J = (e, t, o) => t in e ? z(e, t, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[t] = o;
var f = (e, t, o) => J(e, typeof t != "symbol" ? t + "" : t, o);
import { readFileSync as H, createWriteStream as V } from "node:fs";
import { get as W, createServer as X } from "node:http";
import * as R from "node:path";
import { join as O, resolve as K, extname as Y } from "node:path";
import { createGunzip as Q, createInflate as Z } from "node:zlib";
import { addEventProcessor as q, startSpan as N, getTraceData as ee, captureException as te } from "@sentry/node";
import ne from "launch-editor";
import { DEFAULT_PORT as oe, CONTEXT_LINES_ENDPOINT as ie, SERVER_IDENTIFIER as re } from "./constants.js";
import * as se from "node:os";
import { TraceMap as ae, originalPositionFor as ce, LEAST_UPPER_BOUND as le, sourceContentFor as de } from "@jridgewell/trace-mapping";
async function ue(e) {
  try {
    return (await fetch(e)).text();
  } catch {
    return;
  }
}
function he(e) {
  try {
    return JSON.parse(e);
  } catch {
    return;
  }
}
function pe(e, t) {
  const o = new ae(JSON.parse(e)), n = ce(o, {
    line: t.lineno,
    column: t.colno,
    bias: le
  });
  if (n.source && n.line && n.column) {
    t.lineno = n.line, t.colno = n.column;
    const i = new URL(t.filename).pathname.slice(1);
    t.filename = R.resolve(R.join(R.dirname(i), n.source));
    const r = de(o, n.source), a = (r == null ? void 0 : r.split(se.EOL)) ?? [];
    _(a, t);
  }
  return n;
}
function _(e, t, o = 5) {
  const n = e.length, i = Math.max(Math.min(n - 1, t.lineno - 1), 0);
  t.pre_context = e.slice(Math.max(0, i - o), i).map((r) => v(r, 0)), t.context_line = v(e[Math.min(n - 1, i)], t.colno || 0), t.post_context = e.slice(Math.min(i + 1, n), i + 1 + o).map((r) => v(r, 0));
}
function v(e, t) {
  let o = e;
  const n = o.length;
  if (n <= 150)
    return o;
  t > n && (t = n);
  let i = Math.max(t - 60, 0);
  i < 5 && (i = 0);
  let r = Math.min(i + 140, n);
  return r > n - 5 && (r = n), r === n && (i = Math.max(r - 140, 0)), o = o.slice(i, r), i > 0 && (o = `'{snip} ${o}`), r < n && (o += " {snip}"), o;
}
function fe(e) {
  return !!e.filename && !!e.lineno && !!e.colno;
}
function me(e, t) {
  if (e.method !== "PUT") {
    t.writeHead(405), t.end();
    return;
  }
  let o = "";
  e.on("data", (n) => {
    o += n;
  }), e.on("end", async () => {
    const n = he(o);
    if (!n) {
      t.writeHead(500), t.end();
      return;
    }
    for (const r of n.frames ?? []) {
      if (!fe(r) || // let's ignore dependencies for now with this naive check
      r.filename.includes("/node_modules/"))
        continue;
      const { filename: a } = r;
      if (a.includes("://")) {
        const s = await ue(r.filename);
        if (!s)
          continue;
        const u = s.match(/\/\/# sourceMappingURL=data:application\/json;base64,(.*)/);
        if (u != null && u[1]) {
          const c = u[1], l = Buffer.from(c, "base64").toString("utf-8");
          pe(l, r);
        }
      } else if (!a.includes(":"))
        try {
          const s = H(a, { encoding: "utf-8" }).split(/\r?\n/);
          _(s, r);
        } catch (s) {
          if (s.code !== "ENOENT")
            throw s;
        }
    }
    const i = JSON.stringify(n);
    t.writeHead(200, { "Content-Type": "application/json" }), t.end(i);
  });
}
const b = {
  info: (e) => console.log("🔎 [Spotlight]", e),
  warn: (e) => console.warn("🔎 [Spotlight]", e),
  error: (e) => console.error("🔎 [Spotlight]", e),
  debug: (e) => A && console.debug("🔎 [Spotlight]", e)
};
let S, A = !1;
function ge(e) {
  S = e;
}
function we(e) {
  A = e;
}
const h = {
  info: (e) => (S || b).info(e),
  warn: (e) => (S || b).warn(e),
  error: (e) => (S || b).error(e),
  debug: (e) => (S || b).debug(e)
};
class xe {
  constructor(t = 100) {
    f(this, "size");
    f(this, "items");
    f(this, "writePos", 0);
    f(this, "head", 0);
    f(this, "timeout", 10);
    f(this, "readers", /* @__PURE__ */ new Map());
    this.size = t, this.items = new Array(t);
  }
  put(t) {
    const o = (/* @__PURE__ */ new Date()).getTime();
    this.items[this.writePos % this.size] = [o, t], this.writePos += 1, this.head === this.writePos && (this.head += 1);
    const n = o - this.timeout * 1e3;
    let i;
    for (; this.head < this.writePos && (i = this.items[this.head % this.size], !(i === void 0 || i[0] > n)); )
      this.head += 1;
  }
  subscribe(t) {
    const o = Se();
    return this.readers.set(o, t), setTimeout(() => this.stream(o)), o;
  }
  unsubscribe(t) {
    this.readers.delete(t);
  }
  stream(t, o = this.head) {
    const n = this.readers.get(t);
    if (!n) return;
    let i = o, r;
    for (; r = this.items[i % this.size], !(typeof r > "u" || i >= this.writePos); )
      n(r[1]), i += 1;
    setTimeout(() => this.stream(t, i), 500);
  }
  clear() {
    this.items = new Array(this.size), this.writePos = 0, this.head = 0, this.readers = /* @__PURE__ */ new Map();
  }
}
function Se() {
  let e = (/* @__PURE__ */ new Date()).getTime();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
    let o = Math.random() * 16;
    return o = (e + o) % 16 | 0, e = Math.floor(e / 16), (t === "x" ? o : o & 3 | 8).toString(16);
  });
}
const E = (e, t = {}) => (...o) => N({ name: e.name, ...t }, () => e(...o)), k = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Credentials": "true",
  "Access-Control-Allow-Headers": "*",
  "Access-Control-Allow-Methods": "GET,POST,PUT,OPTIONS,DELETE,PATCH"
}, D = {
  "X-Powered-by": re
}, x = (e) => E(
  (t, o, n, i) => {
    const r = {
      ...k,
      ...D
    };
    for (const [a, s] of Object.entries(r))
      o.setHeader(a, s);
    if (t.method === "OPTIONS") {
      o.writeHead(204, {
        "Cache-Control": "no-cache"
      }), o.end();
      return;
    }
    return e(t, o, n, i);
  },
  { name: "enableCORS", op: "sidecar.http.middleware.cors" }
), Te = (e, t) => function(n, i, r, a) {
  if (n.method === "GET" && n.headers.accept && n.headers.accept === "text/event-stream" && r === "/stream") {
    i.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive"
    }), i.flushHeaders(), i.write(`
`);
    const s = (a == null ? void 0 : a.get("base64")) != null, u = s ? ";base64" : "", c = s ? (d) => i.write(`data:${d.toString("base64")}
`) : (d) => {
      for (const p of d.toString("utf-8").split(`
`))
        i.write(`data:${p}
`);
    }, l = e.subscribe(([d, p]) => {
      h.debug("🕊️ sending to Spotlight"), i.write(`event:${d}${u}
`), c(p), i.write(`
`);
    });
    n.on("close", () => {
      e.unsubscribe(l), i.end();
    });
  } else if (n.method === "POST") {
    h.debug("📩 Received event");
    let s = n;
    const u = n.headers["content-encoding"];
    u === "gzip" ? s = n.pipe(Q()) : u === "deflate" && (s = n.pipe(Z()));
    const c = [];
    s.on("readable", () => {
      for (; ; ) {
        const l = s.read();
        if (l === null)
          break;
        c.push(l);
      }
    }), s.on("end", () => {
      var p, g;
      const l = Buffer.concat(c);
      let d = (p = n.headers["content-type"]) == null ? void 0 : p.split(";")[0].toLocaleLowerCase();
      if ((g = a == null ? void 0 : a.get("sentry_client")) != null && g.startsWith("sentry.javascript.browser") && n.headers.origin && (d = "application/x-sentry-envelope"), d ? e.put([d, l]) : h.warn("No content type, skipping payload..."), process.env.SPOTLIGHT_CAPTURE || t) {
        const T = BigInt(Date.now()) * 1000000n + process.hrtime.bigint() % 1000000n, w = `${(d == null ? void 0 : d.replace(/[^a-z0-9]/gi, "_")) || "no_content_type"}-${T}.txt`;
        if (t)
          t(l.toString("binary"));
        else
          try {
            V(w).write(l), h.info(`🗃️ Saved data to ${w}`);
          } catch (y) {
            h.error(`Failed to save data to ${w}: ${y}`);
          }
      }
      i.writeHead(200, {
        "Cache-Control": "no-cache",
        Connection: "keep-alive"
      }), i.end();
    });
  } else {
    U(n, i);
    return;
  }
}, ye = (e) => function(o, n, i) {
  let r = `${i || o.url}`;
  r === "/" && (r = "/src/index.html"), r = r.slice(1);
  const a = Y(r);
  let s = "text/html";
  switch (a) {
    case ".js":
      s = "text/javascript";
      break;
    case ".css":
      s = "text/css";
      break;
    case ".json":
      s = "application/json";
      break;
  }
  Object.hasOwn(e, r) ? (n.writeHead(200, {
    // Enable profiling in browser
    "Document-Policy": "js-profiling",
    "Content-Type": s
  }), n.end(e[r])) : C(o, n);
};
function be(e, t) {
  t.writeHead(200, {
    "Content-Type": "text/plain",
    ...k,
    ...D
  }), t.end("OK");
}
function Ce(e, t) {
  e.method === "DELETE" ? (t.writeHead(200, {
    "Content-Type": "text/plain"
  }), He(), t.end("Cleared")) : U(e, t);
}
function Ee(e = process.cwd()) {
  return (t, o) => {
    if (t.method !== "POST") {
      o.writeHead(405), o.end();
      return;
    }
    let n = "";
    t.on("data", (i) => {
      n += i;
    }), t.on("end", () => {
      const i = K(e, n);
      h.debug(`Launching editor for ${i}`), ne(
        // filename:line:column
        // both line and column are optional
        i,
        // callback if failed to launch (optional)
        (r, a) => {
          h.error(`Failed to launch editor for ${r}: ${a}`);
        }
      ), o.writeHead(204), o.end();
    });
  };
}
function M(e) {
  return E(
    (t, o) => {
      o.writeHead(e), o.end();
    },
    { name: `HTTP ${e}`, op: `sidecar.http.error.${e}`, attributes: { "http.response.status_code": e } }
  );
}
const C = M(404), U = M(405);
function j(e) {
  h.info(`You can open: http://localhost:${e} to see the Spotlight overlay directly`);
}
function $e(e, t, o, n, i) {
  o && !n && (n = {
    "/src/index.html": H(O(o, "src/index.html")),
    "/assets/main.js": H(O(o, "assets/main.js"))
  });
  const r = [
    [/^\/health$/, be],
    [/^\/clear$/, x(Ce)],
    [/^\/stream$|^\/api\/\d+\/envelope\/?$/, x(Te(e, i))],
    [/^\/open$/, x(Ee(o))],
    [RegExp(`^${ie}$`), x(me)],
    [/^.+$/, n != null ? x(ye(n)) : C]
  ], a = X((c, l) => {
    var y;
    const d = c.url;
    if (!d)
      return C(c, l);
    const p = c.headers.host || "localhost", { pathname: g, searchParams: T } = new URL(d, `http://${p}`), w = r.find(($) => $[0].test(g));
    return w ? N(
      {
        name: `HTTP ${c.method} ${g}`,
        op: `sidecar.http.${(y = c.method) == null ? void 0 : y.toLowerCase()}`,
        forceTransaction: !0,
        attributes: {
          "http.request.method": c.method,
          "http.request.url": d,
          "http.request.query": T.toString(),
          "server.address": p,
          "server.port": c.socket.localPort
        }
      },
      ($) => {
        const L = ee();
        l.appendHeader(
          "server-timing",
          [
            `sentryTrace;desc="${L["sentry-trace"]}"`,
            `baggage;desc="${L.baggage}"`,
            `sentrySpotlightPort;desc=${t}`
          ].join(", ")
        );
        const F = w[1](c, l, g, T);
        return $.setAttribute("http.response.status_code", l.statusCode), F;
      }
    ) : C(c, l);
  });
  return a.on("error", s), a.listen(t, () => {
    u(t, o);
  }), a;
  function s(c) {
    "code" in c && c.code === "EADDRINUSE" ? (h.info(`Port ${t} in use, retrying...`), a.close(), I = setTimeout(() => {
      a.listen(t);
    }, 5e3)) : te(c);
  }
  function u(c, l) {
    h.info(`Sidecar listening on ${c}`), l && j(c);
  }
}
let m, I = null;
const G = new xe(), Re = E(
  (e) => {
    if (typeof e == "string") {
      const t = Number(e);
      return /^\d+$/.test(e) && t > 0 && t <= 65535;
    }
    return e > 0 && e <= 65535;
  },
  { name: "isValidPort", op: "sidecar.server.portCheck" }
), ve = E(
  (e) => new Promise((t) => {
    h.info(`Checking if we are already running on port ${e}`);
    const o = {
      hostname: "localhost",
      port: e,
      path: "/health",
      method: "GET",
      // This is only the socket timeout so set up
      // a connection timeout below manually
      timeout: 1e3,
      headers: { Connection: "close" }
    };
    let n = null;
    const i = W(o, (s) => {
      const u = s.headers["x-powered-by"];
      a(u === "spotlight-by-sentry");
    }), r = () => !i.destroyed && i.destroy(new Error("Request timed out."));
    function a(s) {
      process.off("SIGINT", r), n && clearTimeout(n), t(s);
    }
    process.on("SIGINT", r), n = setTimeout(r, 2e3), i.on("error", () => {
      a(!1);
    }), i.end();
  }),
  { name: "isSidecarRunning", op: "sidecar.server.collideCheck" }
);
function Me({
  port: e,
  logger: t,
  basePath: o,
  filesToServe: n,
  debug: i,
  incomingPayload: r,
  isStandalone: a
} = {}) {
  a || q((u) => {
    var c;
    return (c = u.spans) != null && c.some((l) => {
      var d;
      return (d = l.op) == null ? void 0 : d.startsWith("sidecar.");
    }) ? null : u;
  });
  let s = oe;
  t && ge(t), (i || process.env.SPOTLIGHT_DEBUG) && we(!0), e && !Re(e) ? (h.info("Please provide a valid port."), process.exit(1)) : e && (s = typeof e == "string" ? Number(e) : e), ve(s).then((u) => {
    u ? (h.info(`Sidecar is already running on port ${s}`), (n && "/src/index.html" in n || !n && o) && j(s)) : m || (m = $e(G, s, o, n, r));
  });
}
function He() {
  G.clear();
}
let P = !1;
const B = () => {
  I && clearTimeout(I), (P || !m) && (h.info("Bye."), process.exit(0)), m && (P = !0, h.info("Shutting down server gracefully..."), m.close(), m.closeAllConnections(), m.unref());
};
process.on("SIGINT", B);
process.on("SIGTERM", B);
export {
  He as clearBuffer,
  Me as setupSidecar,
  B as shutdown
};
//# sourceMappingURL=main.js.map
