"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaywrightCheck = void 0;
const node_fs_1 = require("node:fs");
const promises_1 = __importDefault(require("node:fs/promises"));
const check_1 = require("./check");
const project_1 = require("./project");
const util_1 = require("../services/util");
const api_1 = require("../rest/api");
const construct_diagnostics_1 = require("./construct-diagnostics");
const playwright_check_bundle_1 = require("./playwright-check-bundle");
class PlaywrightCheck extends check_1.RuntimeCheck {
    installCommand;
    testCommand;
    playwrightConfigPath;
    pwProjects;
    pwTags;
    include;
    groupName;
    constructor(logicalId, props) {
        super(logicalId, props);
        this.installCommand = props.installCommand;
        this.pwProjects = props.pwProjects
            ? (Array.isArray(props.pwProjects) ? props.pwProjects : [props.pwProjects])
            : [];
        this.pwTags = props.pwTags
            ? (Array.isArray(props.pwTags) ? props.pwTags : [props.pwTags])
            : [];
        this.include = props.include
            ? (Array.isArray(props.include) ? props.include : [props.include])
            : [];
        this.testCommand = props.testCommand ?? 'npx playwright test';
        this.groupName = props.groupName;
        this.playwrightConfigPath = props.playwrightConfigPath;
        project_1.Session.registerConstruct(this);
        this.addSubscriptions();
        this.addPrivateLocationCheckAssignments();
    }
    async validate(diagnostics) {
        try {
            await promises_1.default.access(this.playwrightConfigPath, promises_1.default.constants.R_OK);
        }
        catch (err) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('playwrightConfigPath', new Error(`Playwright config "${this.playwrightConfigPath}" does not exist: ${err.message}`, { cause: err })));
        }
        if (this.groupName) {
            const checkGroup = this.#findGroupByName(this.groupName);
            if (!checkGroup) {
                diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('groupName', new Error(`No such group "${this.groupName}".`)));
            }
        }
    }
    #findGroupByName(groupName) {
        return Object.values(project_1.Session.project?.data?.['check-group'] ?? {})
            .find(group => group.name === groupName);
    }
    getSourceFile() {
        return this.__checkFilePath;
    }
    static buildTestCommand(testCommand, playwrightConfigPath, playwrightProject, playwrightTag) {
        const quotedPath = `"${playwrightConfigPath}"`;
        const projectArg = playwrightProject?.length ? ' --project ' + playwrightProject.map(p => `"${p}"`).join(' ') : '';
        const tagArg = playwrightTag?.length ? ' --grep "' + playwrightTag.join('|').replace(/"/g, '\\"') + '"' : '';
        return `${testCommand} --config ${quotedPath}${projectArg}${tagArg}`;
    }
    static async bundleProject(playwrightConfigPath, include) {
        let dir = '';
        try {
            const { outputFile, browsers, relativePlaywrightConfigPath, cacheHash, } = await (0, util_1.bundlePlayWrightProject)(playwrightConfigPath, include);
            dir = outputFile;
            const { data: { key } } = await PlaywrightCheck.uploadPlaywrightProject(dir);
            return { key, browsers, relativePlaywrightConfigPath, cacheHash };
        }
        finally {
            await (0, util_1.cleanup)(dir);
        }
    }
    static async uploadPlaywrightProject(dir) {
        const { size } = await promises_1.default.stat(dir);
        const stream = (0, node_fs_1.createReadStream)(dir);
        stream.on('error', (err) => {
            throw new Error(`Failed to read Playwright project file: ${err.message}`);
        });
        return api_1.checklyStorage.uploadCodeBundle(stream, size);
    }
    async bundle() {
        let groupId;
        if (this.groupName) {
            const checkGroup = this.#findGroupByName(this.groupName);
            if (checkGroup) {
                groupId = checkGroup.ref();
            }
        }
        const { key: codeBundlePath, browsers, cacheHash, } = await PlaywrightCheck.bundleProject(this.playwrightConfigPath, this.include ?? []);
        return new playwright_check_bundle_1.PlaywrightCheckBundle(this, {
            groupId,
            codeBundlePath,
            browsers,
            cacheHash,
        });
    }
    synthesize() {
        const testCommand = PlaywrightCheck.buildTestCommand(this.testCommand, this.playwrightConfigPath, this.pwProjects, this.pwTags);
        return {
            ...super.synthesize(),
            checkType: 'PLAYWRIGHT',
            testCommand,
            installCommand: this.installCommand,
        };
    }
}
exports.PlaywrightCheck = PlaywrightCheck;
//# sourceMappingURL=playwright-check.js.map