"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRemovedDoubleCheck = exports.validateDeprecatedDoubleCheck = void 0;
const construct_diagnostics_1 = require("../construct-diagnostics");
async function validateDoubleCheck(diagnostics, kind, props) {
    if (props.doubleCheck !== undefined) {
        if (props.doubleCheck) {
            diagnostics.add(new kind('doubleCheck', new Error(`To match the behavior of doubleCheck: true, please use the ` +
                `following retryStrategy instead:` +
                `\n\n` +
                `  RetryStrategyBuilder.fixedStrategy({\n` +
                `    maxRetries: 1,\n` +
                `    baseBackoffSeconds: 0,\n` +
                `    maxDurationSeconds: 600,\n` +
                `    sameRegion: false,\n` +
                `  })`)));
        }
        else {
            diagnostics.add(new kind('doubleCheck', new Error(`To match the behavior of doubleCheck: false, please use the ` +
                `following retryStrategy instead:` +
                `\n\n` +
                `  RetryStrategyBuilder.noRetries()`)));
        }
    }
}
async function validateDeprecatedDoubleCheck(diagnostics, props) {
    if (props.doubleCheck !== undefined) {
        if (props.retryStrategy) {
            diagnostics.add(new construct_diagnostics_1.InvalidPropertyValueDiagnostic('doubleCheck', new Error('Cannot specify both "doubleCheck" and "retryStrategy".')));
        }
        await validateDoubleCheck(diagnostics, construct_diagnostics_1.DeprecatedPropertyDiagnostic, props);
    }
}
exports.validateDeprecatedDoubleCheck = validateDeprecatedDoubleCheck;
async function validateRemovedDoubleCheck(diagnostics, props) {
    await validateDoubleCheck(diagnostics, construct_diagnostics_1.RemovedPropertyDiagnostic, props);
}
exports.validateRemovedDoubleCheck = validateRemovedDoubleCheck;
//# sourceMappingURL=common-diagnostics.js.map