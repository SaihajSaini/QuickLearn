"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const baseCommand_1 = require("./baseCommand");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const fs_1 = require("fs");
const prompts_1 = __importDefault(require("prompts"));
const BASE_RULES_FILE_PATH = (0, path_1.join)(__dirname, '../rules/checkly.rules.md');
// AI IDE configurations mapping
const AI_IDE_CONFIGS = {
    Windsurf: {
        rootFolder: '.windsurf',
        rulesFolder: 'rules',
        rulesFileName: 'checkly.md',
    },
    'GitHub Copilot': {
        rootFolder: '.github/',
        rulesFolder: 'instructions',
        rulesFileName: 'checkly.instructions.md',
    },
    Cursor: {
        rootFolder: '.cursor',
        rulesFolder: 'rules',
        rulesFileName: 'checkly.mdc',
    },
    None: {
        rootFolder: 'None',
        rulesFolder: '',
        rulesFileName: 'checkly.md',
    },
};
class Rules extends baseCommand_1.BaseCommand {
    static hidden = false;
    static description = 'Generate a rules file to use with AI IDEs and Copilots.';
    async run() {
        try {
            // Find AI IDE config folders
            const result = await this.findAIIDEConfigFolder();
            const { configPath, ideType } = result;
            this.log(`Found ${ideType?.rootFolder} config folder: ${configPath}`);
            // Read the base rules file
            const rulesContent = await this.readBaseRulesFile();
            // Create rules directory if it doesn't exist
            const rulesDir = (0, path_1.join)(configPath, ideType.rulesFolder);
            if (ideType.rulesFolder) {
                try {
                    await (0, promises_1.mkdir)(rulesDir, { recursive: true });
                }
                catch {
                    // Directory might already exist, ignore error
                }
            }
            // Determine the target file path
            const targetPath = (0, path_1.join)(rulesDir || configPath, ideType.rulesFileName);
            // Check if file already exists and ask for confirmation
            const shouldOverwrite = await this.confirmOverwrite(targetPath);
            if (!shouldOverwrite) {
                this.log('Operation cancelled.');
                return;
            }
            // Save the rules file
            await (0, promises_1.writeFile)(targetPath, rulesContent, 'utf8');
            this.log(`âœ… Successfully saved Checkly rules file to: ${targetPath}`);
        }
        catch (error) {
            this.error(`Failed to generate rules file: ${error}`);
        }
    }
    async findAIIDEConfigFolder() {
        let currentDir = process.cwd();
        while (true) {
            for (const ideConfig of Object.values(AI_IDE_CONFIGS)) {
                const configPath = (0, path_1.join)(currentDir, ideConfig.rootFolder);
                try {
                    await (0, promises_1.access)(configPath, fs_1.constants.F_OK);
                    return { ideType: ideConfig, configPath };
                }
                catch {
                    // Folder doesn't exist, continue searching
                }
            }
            // Check if we've reached the root directory
            const parentDir = (0, path_1.dirname)(currentDir);
            if (parentDir === currentDir) {
                // We've reached the root directory
                break;
            }
            // Move up one directory
            currentDir = parentDir;
        }
        return {
            configPath: process.cwd(),
            ideType: AI_IDE_CONFIGS.None,
        };
    }
    async readBaseRulesFile() {
        try {
            return await (0, promises_1.readFile)(BASE_RULES_FILE_PATH, 'utf8');
        }
        catch (error) {
            throw new Error(`Failed to read base rules file at ${BASE_RULES_FILE_PATH}: ${error}`);
        }
    }
    async confirmOverwrite(targetPath) {
        try {
            await (0, promises_1.access)(targetPath, fs_1.constants.F_OK);
            // File exists, ask for confirmation
            const { overwrite } = await (0, prompts_1.default)({
                type: 'confirm',
                name: 'overwrite',
                message: `Rules file already exists at ${targetPath}. Do you want to overwrite it?`,
                initial: false,
            });
            return overwrite ?? false;
        }
        catch {
            // File doesn't exist, no need to confirm
            return true;
        }
    }
}
exports.default = Rules;
//# sourceMappingURL=rules.js.map