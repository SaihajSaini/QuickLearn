"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extract = extract;
exports.default = extractAndWrite;
const tslib_1 = require("tslib");
const ts_transformer_1 = require("@formatjs/ts-transformer");
const fs_extra_1 = require("fs-extra");
const console_utils_1 = require("./console_utils");
const icu_messageformat_parser_1 = require("@formatjs/icu-messageformat-parser");
const manipulator_1 = require("@formatjs/icu-messageformat-parser/manipulator");
const printer_1 = require("@formatjs/icu-messageformat-parser/printer");
const json_stable_stringify_1 = tslib_1.__importDefault(require("json-stable-stringify"));
const formatters_1 = require("./formatters");
const parse_script_1 = require("./parse_script");
function calculateLineColFromOffset(text, start) {
    if (!start) {
        return { line: 1, col: 1 };
    }
    const chunk = text.slice(0, start);
    const lines = chunk.split('\n');
    const lastLine = lines[lines.length - 1];
    return { line: lines.length, col: lastLine.length };
}
async function processFile(source, fn, { idInterpolationPattern, ...opts }) {
    let messages = [];
    let meta;
    const onMsgExtracted = opts.onMsgExtracted;
    const onMetaExtracted = opts.onMetaExtracted;
    opts = {
        ...opts,
        additionalComponentNames: [
            '$formatMessage',
            ...(opts.additionalComponentNames || []),
        ],
        onMsgExtracted(filePath, msgs) {
            if (opts.extractSourceLocation) {
                msgs = msgs.map(msg => ({
                    ...msg,
                    ...calculateLineColFromOffset(source, msg.start),
                }));
            }
            messages = messages.concat(msgs);
            if (onMsgExtracted) {
                onMsgExtracted(filePath, msgs);
            }
        },
        onMetaExtracted(filePath, m) {
            meta = m;
            if (onMetaExtracted) {
                onMetaExtracted(filePath, m);
            }
        },
    };
    if (!opts.overrideIdFn && idInterpolationPattern) {
        opts = {
            ...opts,
            overrideIdFn: (id, defaultMessage, description, fileName) => id ||
                (0, ts_transformer_1.interpolateName)({
                    resourcePath: fileName,
                }, idInterpolationPattern, {
                    content: description
                        ? `${defaultMessage}#${typeof description === 'string'
                            ? description
                            : (0, json_stable_stringify_1.default)(description)}`
                        : defaultMessage,
                }),
        };
    }
    (0, console_utils_1.debug)('Processing opts for %s: %s', fn, opts);
    const scriptParseFn = (0, parse_script_1.parseScript)(opts, fn);
    if (fn.endsWith('.vue')) {
        (0, console_utils_1.debug)('Processing %s using vue extractor', fn);
        const { parseFile } = await import('./vue_extractor.js');
        parseFile(source, fn, scriptParseFn);
    }
    else if (fn.endsWith('.hbs')) {
        (0, console_utils_1.debug)('Processing %s using hbs extractor', fn);
        const { parseFile } = await import('./hbs_extractor.js');
        parseFile(source, fn, opts);
    }
    else if (fn.endsWith('.gts') || fn.endsWith('.gjs')) {
        (0, console_utils_1.debug)('Processing %s as gts/gjs file', fn);
        const { parseFile } = await import('./gts_extractor.js');
        parseFile(source, fn, opts);
    }
    else {
        (0, console_utils_1.debug)('Processing %s using typescript extractor', fn);
        scriptParseFn(source);
    }
    (0, console_utils_1.debug)('Done extracting %s messages: %s', fn, messages);
    if (meta) {
        (0, console_utils_1.debug)('Extracted meta:', meta);
        messages.forEach(m => (m.meta = meta));
    }
    return { messages, meta };
}
/**
 * Extract strings from source files
 * @param files list of files
 * @param extractOpts extract options
 * @returns messages serialized as JSON string since key order
 * matters for some `format`
 */
async function extract(files, extractOpts) {
    const { throws, readFromStdin, flatten, ...opts } = extractOpts;
    let rawResults = [];
    try {
        if (readFromStdin) {
            (0, console_utils_1.debug)(`Reading input from stdin`);
            // Read from stdin
            if (process.stdin.isTTY) {
                (0, console_utils_1.warn)('Reading source file from TTY.');
            }
            const stdinSource = await (0, console_utils_1.getStdinAsString)();
            rawResults = [await processFile(stdinSource, 'dummy', opts)];
        }
        else {
            rawResults = await Promise.all(files.map(async (fn) => {
                (0, console_utils_1.debug)('Extracting file:', fn);
                const source = await (0, fs_extra_1.readFile)(fn, 'utf8');
                return processFile(source, fn, opts);
            }));
        }
    }
    catch (e) {
        if (throws) {
            throw e;
        }
        else {
            (0, console_utils_1.warn)(String(e));
        }
    }
    const formatter = await (0, formatters_1.resolveBuiltinFormatter)(opts.format);
    const extractionResults = rawResults.filter((r) => !!r);
    const extractedMessages = new Map();
    for (const { messages } of extractionResults) {
        for (const message of messages) {
            const { id, description, defaultMessage } = message;
            if (!id) {
                const error = new Error(`[FormatJS CLI] Missing message id for message:
${JSON.stringify(message, undefined, 2)}`);
                if (throws) {
                    throw error;
                }
                else {
                    (0, console_utils_1.warn)(error.message);
                }
                continue;
            }
            if (extractedMessages.has(id)) {
                const existing = extractedMessages.get(id);
                if ((0, json_stable_stringify_1.default)(description) !== (0, json_stable_stringify_1.default)(existing.description) ||
                    defaultMessage !== existing.defaultMessage) {
                    const error = new Error(`[FormatJS CLI] Duplicate message id: "${id}", ` +
                        'but the `description` and/or `defaultMessage` are different.');
                    if (throws) {
                        throw error;
                    }
                    else {
                        (0, console_utils_1.warn)(error.message);
                    }
                }
            }
            extractedMessages.set(id, message);
        }
    }
    const results = {};
    const messages = Array.from(extractedMessages.values());
    for (const { id, ...msg } of messages) {
        if (flatten && msg.defaultMessage) {
            msg.defaultMessage = (0, printer_1.printAST)((0, manipulator_1.hoistSelectors)((0, icu_messageformat_parser_1.parse)(msg.defaultMessage)));
        }
        results[id] = msg;
    }
    if (typeof formatter.serialize === 'function') {
        return formatter.serialize(formatter.format(results));
    }
    return (0, json_stable_stringify_1.default)(formatter.format(results), {
        space: 2,
        cmp: formatter.compareMessages || undefined,
    });
}
/**
 * Extract strings from source files, also writes to a file.
 * @param files list of files
 * @param extractOpts extract options
 * @returns A Promise that resolves if output file was written successfully
 */
async function extractAndWrite(files, extractOpts) {
    const { outFile, ...opts } = extractOpts;
    const serializedResult = (await extract(files, opts)) + '\n';
    if (outFile) {
        (0, console_utils_1.debug)('Writing output file:', outFile);
        return (0, fs_extra_1.outputFile)(outFile, serializedResult);
    }
    await (0, console_utils_1.writeStdout)(serializedResult);
}
