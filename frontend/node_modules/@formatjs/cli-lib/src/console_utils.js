"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeStdout = exports.writeStderr = void 0;
exports.clearLine = clearLine;
exports.debug = debug;
exports.warn = warn;
exports.error = error;
exports.getStdinAsString = getStdinAsString;
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const readline_1 = tslib_1.__importDefault(require("readline"));
const util_1 = require("util");
const CLEAR_WHOLE_LINE = 0;
exports.writeStderr = (0, util_1.promisify)(process.stderr.write).bind(process.stderr);
exports.writeStdout = (0, util_1.promisify)(process.stdout.write).bind(process.stdout);
const nativeClearLine = (0, util_1.promisify)(readline_1.default.clearLine).bind(readline_1.default);
const nativeCursorTo = (0, util_1.promisify)(readline_1.default.cursorTo).bind(readline_1.default);
// From:
// https://github.com/yarnpkg/yarn/blob/53d8004229f543f342833310d5af63a4b6e59c8a/src/reporters/console/util.js
async function clearLine(terminal) {
    if (!chalk_1.supportsColor) {
        if (terminal.isTTY) {
            // terminal
            if (terminal.columns > 0) {
                await (0, exports.writeStderr)(`\r${' '.repeat(terminal.columns - 1)}`);
            }
            await (0, exports.writeStderr)(`\r`);
        }
        // ignore piping to file
    }
    else {
        await nativeClearLine(terminal, CLEAR_WHOLE_LINE);
        await nativeCursorTo(terminal, 0, undefined);
    }
}
const LEVEL_COLORS = {
    debug: chalk_1.green,
    warn: chalk_1.yellow,
    error: chalk_1.red,
};
function label(level, message) {
    return `[@formatjs/cli] [${LEVEL_COLORS[level](level.toUpperCase())}] ${message}`;
}
async function debug(message, ...args) {
    if (process.env.LOG_LEVEL !== 'debug') {
        return;
    }
    await clearLine(process.stderr);
    await (0, exports.writeStderr)((0, util_1.format)(label('debug', message), ...args));
    await (0, exports.writeStderr)('\n');
}
async function warn(message, ...args) {
    await clearLine(process.stderr);
    await (0, exports.writeStderr)((0, util_1.format)(label('warn', message), ...args));
    await (0, exports.writeStderr)('\n');
}
async function error(message, ...args) {
    await clearLine(process.stderr);
    await (0, exports.writeStderr)((0, util_1.format)(label('error', message), ...args));
    await (0, exports.writeStderr)('\n');
}
function getStdinAsString() {
    let result = '';
    return new Promise(resolve => {
        process.stdin.setEncoding('utf-8');
        process.stdin.on('readable', () => {
            let chunk;
            while ((chunk = process.stdin.read())) {
                result += chunk;
            }
        });
        process.stdin.on('end', () => {
            resolve(result);
        });
    });
}
