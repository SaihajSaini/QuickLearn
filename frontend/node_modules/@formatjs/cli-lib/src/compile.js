"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = compile;
exports.default = compileAndWrite;
const tslib_1 = require("tslib");
const icu_messageformat_parser_1 = require("@formatjs/icu-messageformat-parser");
const fs_extra_1 = require("fs-extra");
const json_stable_stringify_1 = tslib_1.__importDefault(require("json-stable-stringify"));
const console_utils_1 = require("./console_utils");
const formatters_1 = require("./formatters");
const pseudo_locale_1 = require("./pseudo_locale");
/**
 * Aggregate `inputFiles` into a single JSON blob and compile.
 * Also checks for conflicting IDs.
 * Then returns the serialized result as a `string` since key order
 * makes a difference in some vendor.
 * @param inputFiles Input files
 * @param opts Options
 * @returns serialized result in string format
 */
async function compile(inputFiles, opts = {}) {
    (0, console_utils_1.debug)('Compiling files:', inputFiles);
    const { ast, format, pseudoLocale, skipErrors, ignoreTag } = opts;
    const formatter = await (0, formatters_1.resolveBuiltinFormatter)(format);
    const messages = {};
    const messageAsts = {};
    const idsWithFileName = {};
    const compiledFiles = await Promise.all(inputFiles.map(f => (0, fs_extra_1.readJSON)(f).then(formatter.compile)));
    (0, console_utils_1.debug)('Compiled files:', compiledFiles);
    for (let i = 0; i < inputFiles.length; i++) {
        const inputFile = inputFiles[i];
        (0, console_utils_1.debug)('Processing file:', inputFile);
        const compiled = compiledFiles[i];
        for (const id in compiled) {
            if (messages[id] && messages[id] !== compiled[id]) {
                throw new Error(`Conflicting ID "${id}" with different translation found in these 2 files:
ID: ${id}
Message from ${idsWithFileName[id]}: ${messages[id]}
Message from ${inputFile}: ${compiled[id]}
`);
            }
            try {
                const msgAst = (0, icu_messageformat_parser_1.parse)(compiled[id], { ignoreTag });
                messages[id] = compiled[id];
                switch (pseudoLocale) {
                    case 'xx-LS':
                        messageAsts[id] = (0, pseudo_locale_1.generateXXLS)(msgAst);
                        break;
                    case 'xx-AC':
                        messageAsts[id] = (0, pseudo_locale_1.generateXXAC)(msgAst);
                        break;
                    case 'xx-HA':
                        messageAsts[id] = (0, pseudo_locale_1.generateXXHA)(msgAst);
                        break;
                    case 'en-XA':
                        messageAsts[id] = (0, pseudo_locale_1.generateENXA)(msgAst);
                        break;
                    case 'en-XB':
                        messageAsts[id] = (0, pseudo_locale_1.generateENXB)(msgAst);
                        break;
                    default:
                        messageAsts[id] = msgAst;
                        break;
                }
                idsWithFileName[id] = inputFile;
            }
            catch (e) {
                (0, console_utils_1.warn)('Error validating message "%s" with ID "%s" in file "%s"', compiled[id], id, inputFile);
                if (!skipErrors) {
                    throw e;
                }
            }
        }
    }
    return (0, json_stable_stringify_1.default)(ast ? messageAsts : messages, {
        space: 2,
        cmp: formatter.compareMessages || undefined,
    });
}
/**
 * Aggregate `inputFiles` into a single JSON blob and compile.
 * Also checks for conflicting IDs and write output to `outFile`.
 * @param inputFiles Input files
 * @param compileOpts options
 * @returns A `Promise` that resolves if file was written successfully
 */
async function compileAndWrite(inputFiles, compileOpts = {}) {
    const { outFile, ...opts } = compileOpts;
    const serializedResult = (await compile(inputFiles, opts)) + '\n';
    if (outFile) {
        (0, console_utils_1.debug)('Writing output file:', outFile);
        return (0, fs_extra_1.outputFile)(outFile, serializedResult);
    }
    await (0, console_utils_1.writeStdout)(serializedResult);
}
