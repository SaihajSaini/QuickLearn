"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasDiff = exports.compareTranslationFiles = exports.findInvalidTranslations = void 0;
const icu_messageformat_parser_1 = require("@formatjs/icu-messageformat-parser");
const findInvalidTranslations = (source, files) => {
    const differences = {};
    if (Object.keys(files).length === 0) {
        return differences;
    }
    for (const [lang, file] of Object.entries(files)) {
        const result = (0, exports.compareTranslationFiles)(source, file);
        if (result.length > 0) {
            differences[lang] = result;
        }
    }
    return differences;
};
exports.findInvalidTranslations = findInvalidTranslations;
const sortParsedKeys = (a, b) => {
    if (a.type === b.type) {
        return !(0, icu_messageformat_parser_1.isPoundElement)(a) && !(0, icu_messageformat_parser_1.isPoundElement)(b)
            ? a.value < b.value
                ? -1
                : 1
            : -1;
    }
    return a.type - b.type;
};
const compareTranslationFiles = (a, b) => {
    const diffs = [];
    for (const key in a) {
        if (b[key] === undefined) {
            continue;
        }
        const parsedTranslationA = (0, icu_messageformat_parser_1.parse)(String(a[key]));
        const parsedTranslationB = (0, icu_messageformat_parser_1.parse)(String(b[key]));
        if ((0, exports.hasDiff)(parsedTranslationA, parsedTranslationB)) {
            const msg = getErrorMessage(parsedTranslationA, parsedTranslationB);
            diffs.push({ key, msg });
        }
    }
    return diffs;
};
exports.compareTranslationFiles = compareTranslationFiles;
const hasDiff = (a, b) => {
    const compA = a
        .filter((element) => !(0, icu_messageformat_parser_1.isLiteralElement)(element))
        .sort(sortParsedKeys);
    const compB = b
        .filter((element) => !(0, icu_messageformat_parser_1.isLiteralElement)(element))
        .sort(sortParsedKeys);
    if (compA.length !== compB.length) {
        return true;
    }
    const hasErrors = compA.some((formatElementA, index) => {
        const formatElementB = compB[index];
        if (formatElementA.type !== formatElementB.type ||
            formatElementA.location !== formatElementB.location) {
            return true;
        }
        if (((0, icu_messageformat_parser_1.isLiteralElement)(formatElementA) && (0, icu_messageformat_parser_1.isLiteralElement)(formatElementB)) ||
            ((0, icu_messageformat_parser_1.isPoundElement)(formatElementA) && (0, icu_messageformat_parser_1.isPoundElement)(formatElementB))) {
            return false;
        }
        if (!(0, icu_messageformat_parser_1.isPoundElement)(formatElementA) &&
            !(0, icu_messageformat_parser_1.isPoundElement)(formatElementB) &&
            formatElementA.value !== formatElementB.value) {
            return true;
        }
        if ((0, icu_messageformat_parser_1.isTagElement)(formatElementA) && (0, icu_messageformat_parser_1.isTagElement)(formatElementB)) {
            return (0, exports.hasDiff)(formatElementA.children, formatElementB.children);
        }
        if ((0, icu_messageformat_parser_1.isSelectElement)(formatElementA) && (0, icu_messageformat_parser_1.isSelectElement)(formatElementB)) {
            const optionsA = Object.keys(formatElementA.options).sort();
            const optionsB = Object.keys(formatElementB.options).sort();
            if (optionsA.join('-') !== optionsB.join('-')) {
                return true;
            }
            return optionsA.some((key) => {
                return (0, exports.hasDiff)(formatElementA.options[key].value, formatElementB.options[key].value);
            });
        }
        if ((0, icu_messageformat_parser_1.isPluralElement)(formatElementA) && (0, icu_messageformat_parser_1.isPluralElement)(formatElementB)) {
            const optionsA = Object.keys(formatElementA.options).sort();
            return optionsA.some((key) => {
                // We can only compare translations that have the same plural keys.
                // In English, we might have "one", "other", but in German, we might have "one", "few", "other".
                // Or, in Arabic it might just be "other".
                // So, we'll have to skip over the ones that don't have a one-to-one match.
                if (!formatElementB.options[key]) {
                    return false;
                }
                return (0, exports.hasDiff)(formatElementA.options[key].value, formatElementB.options[key].value);
            });
        }
        return false;
    });
    return hasErrors;
};
exports.hasDiff = hasDiff;
const getErrorMessage = (a, b) => {
    const compA = a
        .filter((element) => !(0, icu_messageformat_parser_1.isLiteralElement)(element))
        .sort(sortParsedKeys);
    const compB = b
        .filter((element) => !(0, icu_messageformat_parser_1.isLiteralElement)(element))
        .sort(sortParsedKeys);
    const errors = compA.reduce((acc, formatElementA, index) => {
        const formatElementB = compB[index];
        if (!formatElementB) {
            acc.push(`Missing element ${typeLookup[formatElementA.type]}`);
            return acc;
        }
        if (formatElementA.type !== formatElementB.type) {
            acc.push(`Expected element of type "${typeLookup[formatElementA.type]}" but received "${typeLookup[formatElementB.type]}"`);
            return acc;
        }
        if (formatElementA.location !== formatElementB.location) {
            acc.push(`Expected location to be ${formatElementA.location?.start?.line}:${formatElementA.location?.start?.column}`);
            return acc;
        }
        if ((0, icu_messageformat_parser_1.isPoundElement)(formatElementA) && (0, icu_messageformat_parser_1.isPoundElement)(formatElementB)) {
            return acc;
        }
        if (!(0, icu_messageformat_parser_1.isPoundElement)(formatElementA) &&
            !(0, icu_messageformat_parser_1.isPoundElement)(formatElementB) &&
            formatElementA.value !== formatElementB.value) {
            acc.push(`Expected ${typeLookup[formatElementA.type]} to contain "${formatElementA.value}" but received "${formatElementB.value}"`);
            return acc;
        }
        if ((0, icu_messageformat_parser_1.isTagElement)(formatElementA) && (0, icu_messageformat_parser_1.isTagElement)(formatElementB)) {
            acc.push(`Error in pound element: ${getErrorMessage(formatElementA.children, formatElementB.children)}`);
            return acc;
        }
        if ((0, icu_messageformat_parser_1.isSelectElement)(formatElementA) && (0, icu_messageformat_parser_1.isSelectElement)(formatElementB)) {
            const optionsA = Object.keys(formatElementA.options).sort();
            const elementErrors = [];
            optionsA.forEach((key) => {
                if (formatElementB.options[key]) {
                    elementErrors.push(getErrorMessage(formatElementA.options[key].value, formatElementB.options[key].value));
                }
            });
            acc.push(`Error in select: ${elementErrors
                .flatMap((elementError) => elementError)
                .join(', ')}`);
            return acc;
        }
        if ((0, icu_messageformat_parser_1.isPluralElement)(formatElementA) && (0, icu_messageformat_parser_1.isPluralElement)(formatElementB)) {
            const optionsA = Object.keys(formatElementA.options).sort();
            const elementErrors = [];
            optionsA.forEach((key) => {
                if (formatElementB.options[key]) {
                    elementErrors.push(getErrorMessage(formatElementA.options[key].value, formatElementB.options[key].value));
                }
            });
            acc.push(`Error in plural: ${elementErrors
                .flatMap((elementError) => elementError)
                .join(', ')}`);
            return acc;
        }
        return acc;
    }, []);
    if (compA.length < compB.length) {
        const unexpectedElements = compB
            .slice(compA.length)
            .reduce((acc, formatElementB) => {
            acc.push(`Unexpected ${typeLookup[formatElementB.type]} element`);
            return acc;
        }, [])
            .join(', ');
        return [...errors, unexpectedElements].join(', ');
    }
    return errors.join(', ');
};
const typeLookup = {
    0: 'literal',
    1: 'argument',
    2: 'number',
    3: 'date',
    4: 'time',
    5: 'select',
    6: 'plural',
    7: 'pound',
    8: 'tag',
};
