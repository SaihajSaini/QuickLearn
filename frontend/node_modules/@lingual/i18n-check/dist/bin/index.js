#! /usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = __importDefault(require("node:fs"));
const node_process_1 = require("node:process");
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = require("commander");
const glob_1 = require("glob");
const js_yaml_1 = __importDefault(require("js-yaml"));
const __1 = require("..");
const errorReporters_1 = require("../errorReporters");
const flattenTranslations_1 = require("../utils/flattenTranslations");
const node_path_1 = __importDefault(require("node:path"));
const version = require('../../package.json').version;
commander_1.program
    .version(version)
    .option('-l, --locales <locales...>', 'name of the directory containing the locales to validate')
    .option('-s, --source <locale>', 'the source locale to validate against')
    .option('-f, --format <type>', 'define the specific format: i18next, react-intl or next-intl')
    .option('-c, --check <checks...>', 'this option is deprecated - use -o or --only instead')
    .option('-o, --only <only...>', 'define the specific checks you want to run: invalidKeys, missingKeys, unused, undefined. By default the check will validate against missing and invalid keys, i.e. --only invalidKeys,missingKeys')
    .option('-r, --reporter <style>', 'define the reporting style: standard or summary')
    .option('-e, --exclude <exclude...>', 'define the file(s) and/or folders(s) that should be excluded from the check')
    .option('-i, --ignore <ignore...>', 'define the key(s) or group of keys (i.e. `some.namespace.*`) that should be excluded from the check')
    .option('-u, --unused <paths...>', 'define the source path(s) to find all unused and undefined keys')
    .option('--parser-component-functions <components...>', 'a list of component names to parse when using the --unused option')
    .parse();
const getCheckOptions = () => {
    const checkOption = commander_1.program.getOptionValue('only') || commander_1.program.getOptionValue('check');
    if (commander_1.program.getOptionValue('check')) {
        console.log(chalk_1.default.yellow('The --check option has been deprecated, use the --only option instead.'));
    }
    if (!checkOption) {
        return errorReporters_1.CheckOptions;
    }
    const checks = checkOption.filter((check) => errorReporters_1.CheckOptions.includes(check.trim()));
    return checks.length > 0 ? checks : errorReporters_1.CheckOptions;
};
const isSource = (fileInfo, srcPath) => {
    return (fileInfo.path.some((path) => path.toLowerCase() === srcPath.toLowerCase()) || fileInfo.name.toLowerCase().slice(0, -5) === srcPath.toLowerCase());
};
const main = async () => {
    const start = performance.now();
    const srcPath = commander_1.program.getOptionValue('source');
    const localePath = commander_1.program.getOptionValue('locales');
    const format = commander_1.program.getOptionValue('format');
    const exclude = commander_1.program.getOptionValue('exclude');
    const ignore = commander_1.program.getOptionValue('ignore');
    const unusedSrcPath = commander_1.program.getOptionValue('unused');
    const componentFunctions = commander_1.program.getOptionValue('parserComponentFunctions');
    if (!srcPath) {
        console.log(chalk_1.default.red('Source not found. Please provide a valid source locale, i.e. -s en-US'));
        (0, node_process_1.exit)(1);
    }
    if (!localePath || localePath.length === 0) {
        console.log(chalk_1.default.red('Locale file(s) not found. Please provide valid locale file(s), i.e. -locales translations/'));
        (0, node_process_1.exit)(1);
    }
    const excludedPaths = exclude ?? [];
    const localePathFolders = localePath;
    const isMultiFolders = localePathFolders.length > 1;
    const srcFiles = [];
    const targetFiles = [];
    const pattern = isMultiFolders
        ? `{${localePath.join(',').trim()}}/**/*.{json,yaml,yml}`
        : `${localePath.join(',').trim()}/**/*.{json,yaml,yml}`;
    const files = await (0, glob_1.glob)(pattern, {
        ignore: ['node_modules/**'].concat(excludedPaths),
        windowsPathsNoEscape: true,
    });
    console.log('i18n translations checker');
    console.log(chalk_1.default.gray(`Source: ${srcPath}`));
    if (format) {
        console.log(chalk_1.default.blackBright(`Selected format is: ${format}`));
    }
    const options = {
        checks: getCheckOptions(),
        format: format ?? undefined,
        ignore,
    };
    const fileInfos = [];
    files.sort().forEach((file) => {
        const filePath = file.split(node_path_1.default.sep);
        const name = filePath.pop() ?? '';
        const extension = name.split('.').pop() ?? 'json';
        fileInfos.push({
            extension,
            file,
            name,
            path: filePath,
        });
    });
    fileInfos.forEach(({ extension, file, name, path }) => {
        let rawContent;
        if (extension === 'yaml') {
            rawContent = js_yaml_1.default.load(node_fs_1.default.readFileSync(file, 'utf-8'));
        }
        else {
            rawContent = JSON.parse(node_fs_1.default.readFileSync(file, 'utf-8'));
        }
        const content = (0, flattenTranslations_1.flattenTranslations)(rawContent);
        if (isSource({ file, name, path }, srcPath)) {
            srcFiles.push({
                reference: null,
                name: file,
                content,
            });
        }
        else {
            const fullPath = path.join('-');
            const reference = fileInfos.find((fileInfo) => {
                if (!isSource(fileInfo, srcPath)) {
                    return false;
                }
                if (fileInfo.path.join('-') === fullPath) {
                    return true;
                }
                // Check if the folder path matches - ignoring the last folder
                // Then check if the file names are the same
                // Example folder structure:
                // path/to/locales/
                //   en-US/
                //      one.json
                //      two.json
                //      three.json
                //   de-DE/
                //      one.json
                //      two.json
                //      three.json
                //
                // Referencing: `path/to/locales/en-US/one.json`, `path/to/locales/de-DE/one.json`
                // Non Referencing: `path/to/locales/en-US/one.json`, `path/to/other/locales/de-DE/one.json`
                if (fileInfo.path.slice(0, fileInfo.path.length - 1).join('-') ===
                    path.slice(0, path.length - 1).join('-')) {
                    return fileInfo.name === name;
                }
                return false;
            });
            if (reference) {
                targetFiles.push({
                    reference: reference.file,
                    name: file,
                    content,
                });
            }
        }
    });
    if (srcFiles.length === 0) {
        console.log(chalk_1.default.red('Source not found. Please provide a valid source locale, i.e. -s en-US'));
        (0, node_process_1.exit)(1);
    }
    if ((options.checks.includes('missingKeys') ||
        options.checks.includes('invalidKeys')) &&
        targetFiles.length === 0) {
        console.log(chalk_1.default.red('Locale file(s) not found. Please provide valid locale file(s), i.e. --locales translations/'));
        (0, node_process_1.exit)(1);
    }
    try {
        const result = (0, __1.checkTranslations)(srcFiles, targetFiles, options);
        printTranslationResult(result);
        if (unusedSrcPath) {
            const isMultiUnusedFolders = unusedSrcPath.length > 1;
            const pattern = isMultiUnusedFolders
                ? `{${unusedSrcPath.join(',').trim()}}/**/*.{ts,tsx}`
                : `${unusedSrcPath.join(',').trim()}/**/*.{ts,tsx}`;
            const filesToParse = (0, glob_1.globSync)(pattern, {
                ignore: ['node_modules/**'],
                windowsPathsNoEscape: true,
            });
            const unusedKeys = await (0, __1.checkUnusedKeys)(srcFiles, filesToParse, options, componentFunctions);
            printUnusedKeysResult({ unusedKeys });
            const undefinedKeys = await (0, __1.checkUndefinedKeys)(srcFiles, filesToParse, options, componentFunctions);
            printUndefinedKeysResult({
                undefinedKeys,
            });
        }
        const end = performance.now();
        console.log(chalk_1.default.green(`\nDone in ${Math.round(((end - start) * 100) / 1000) / 100}s.`));
        if ((result.missingKeys && Object.keys(result.missingKeys).length > 0) ||
            (result.invalidKeys && Object.keys(result.invalidKeys).length > 0)) {
            (0, node_process_1.exit)(1);
        }
        else {
            (0, node_process_1.exit)(0);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
    }
    catch (e) {
        console.log(chalk_1.default.red("\nError: Can't validate translations. Check if the format is supported or specify the translation format i.e. -f i18next"));
        (0, node_process_1.exit)(1);
    }
};
const printTranslationResult = ({ missingKeys, invalidKeys, }) => {
    const reporter = commander_1.program.getOptionValue('reporter');
    const isSummary = reporter === 'summary';
    if (missingKeys && Object.keys(missingKeys).length > 0) {
        console.log(chalk_1.default.red('\nFound missing keys!'));
        if (isSummary) {
            console.log(chalk_1.default.red((0, errorReporters_1.formatSummaryTable)(missingKeys)));
        }
        else {
            const table = (0, errorReporters_1.formatCheckResultTable)(missingKeys);
            console.log(chalk_1.default.red(table));
        }
    }
    else if (missingKeys) {
        console.log(chalk_1.default.green('\nNo missing keys found!'));
    }
    if (invalidKeys && Object.keys(invalidKeys).length > 0) {
        console.log(chalk_1.default.red('\nFound invalid keys!'));
        if (isSummary) {
            console.log(chalk_1.default.red((0, errorReporters_1.formatSummaryTable)(invalidKeys)));
        }
        else {
            const table = (0, errorReporters_1.formatInvalidTranslationsResultTable)(invalidKeys);
            console.log(chalk_1.default.red(table));
        }
    }
    else if (invalidKeys) {
        console.log(chalk_1.default.green('\nNo invalid translations found!'));
    }
};
const printUnusedKeysResult = ({ unusedKeys, }) => {
    const reporter = commander_1.program.getOptionValue('reporter');
    const isSummary = reporter === 'summary';
    if (unusedKeys && hasKeys(unusedKeys)) {
        console.log(chalk_1.default.red('\nFound unused keys!'));
        if (isSummary) {
            console.log(chalk_1.default.red((0, errorReporters_1.formatSummaryTable)(unusedKeys)));
        }
        else {
            console.log(chalk_1.default.red((0, errorReporters_1.formatCheckResultTable)(unusedKeys)));
        }
    }
    else if (unusedKeys) {
        console.log(chalk_1.default.green('\nNo unused keys found!'));
    }
};
const printUndefinedKeysResult = ({ undefinedKeys, }) => {
    const reporter = commander_1.program.getOptionValue('reporter');
    const isSummary = reporter === 'summary';
    if (undefinedKeys && hasKeys(undefinedKeys)) {
        console.log(chalk_1.default.red('\nFound undefined keys!'));
        if (isSummary) {
            console.log(chalk_1.default.red((0, errorReporters_1.formatSummaryTable)(undefinedKeys)));
        }
        else {
            console.log(chalk_1.default.red((0, errorReporters_1.formatCheckResultTable)(undefinedKeys)));
        }
    }
    else if (undefinedKeys) {
        console.log(chalk_1.default.green('\nNo undefined keys found!'));
    }
};
const hasKeys = (checkResult) => {
    for (const [_, keys] of Object.entries(checkResult)) {
        if (keys.length > 0) {
            return true;
        }
    }
    return false;
};
main();
