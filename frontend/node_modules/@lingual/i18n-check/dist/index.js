"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkUndefinedKeys = exports.checkUnusedKeys = exports.checkTranslations = exports.checkMissingTranslations = exports.checkInvalidTranslations = void 0;
const findMissingKeys_1 = require("./utils/findMissingKeys");
const findInvalidTranslations_1 = require("./utils/findInvalidTranslations");
const findInvalidi18nTranslations_1 = require("./utils/findInvalidi18nTranslations");
const cli_lib_1 = require("@formatjs/cli-lib");
const nextIntlSrcParser_1 = require("./utils/nextIntlSrcParser");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ParseFormats = ['react-intl', 'i18next', 'next-intl'];
const checkInvalidTranslations = (source, targets, options = { format: 'icu' }) => {
    return options.format === 'i18next'
        ? (0, findInvalidi18nTranslations_1.findInvalid18nTranslations)(source, targets)
        : (0, findInvalidTranslations_1.findInvalidTranslations)(source, targets);
};
exports.checkInvalidTranslations = checkInvalidTranslations;
const checkMissingTranslations = (source, targets) => {
    return (0, findMissingKeys_1.findMissingKeys)(source, targets);
};
exports.checkMissingTranslations = checkMissingTranslations;
const checkTranslations = (source, targets, options = { format: 'icu', checks: ['invalidKeys', 'missingKeys'] }) => {
    const { checks = ['invalidKeys', 'missingKeys'] } = options;
    const missingKeys = {};
    const invalidKeys = {};
    const hasMissingKeysCheck = checks.includes('missingKeys');
    const hasInvalidKeysCheck = checks.includes('invalidKeys');
    source.forEach(({ name, content }) => {
        const files = Object.fromEntries(targets
            .filter(({ reference }) => reference === name)
            .map(({ name, content }) => [name, content]));
        if (hasMissingKeysCheck) {
            const filteredContent = filterKeys(content, options.ignore ?? []);
            merge(missingKeys, (0, exports.checkMissingTranslations)(filteredContent, files));
        }
        if (hasInvalidKeysCheck) {
            merge(invalidKeys, (0, exports.checkInvalidTranslations)(content, files, options));
        }
    });
    return {
        missingKeys: hasMissingKeysCheck ? missingKeys : undefined,
        invalidKeys: hasInvalidKeysCheck ? invalidKeys : undefined,
    };
};
exports.checkTranslations = checkTranslations;
function merge(left, right) {
    for (const [k, v] of Object.entries(right)) {
        left[k] = (left?.[k] ?? []).concat(v);
    }
}
const checkUnusedKeys = async (translationFiles, filesToParse, options = {
    format: 'react-intl',
    checks: [],
}, componentFunctions = []) => {
    if (!options.format || !ParseFormats.includes(options.format)) {
        return undefined;
    }
    if (!options.checks || !options.checks.includes('unused')) {
        return undefined;
    }
    if (options.format === 'react-intl') {
        return findUnusedReactIntlTranslations(translationFiles, filesToParse);
    }
    else if (options.format === 'i18next') {
        return findUnusedI18NextTranslations(translationFiles, filesToParse, componentFunctions);
    }
    else if (options.format === 'next-intl') {
        return findUnusedNextIntlTranslations(translationFiles, filesToParse);
    }
};
exports.checkUnusedKeys = checkUnusedKeys;
const findUnusedReactIntlTranslations = async (translationFiles, filesToParse) => {
    const unusedKeys = {};
    const extracted = await (0, cli_lib_1.extract)(filesToParse, {});
    const extractedResultSet = new Set(Object.keys(JSON.parse(extracted)));
    translationFiles.forEach(({ name, content }) => {
        const keysInSource = Object.keys(content);
        const found = [];
        for (const keyInSource of keysInSource) {
            if (!extractedResultSet.has(keyInSource)) {
                found.push(keyInSource);
            }
        }
        unusedKeys[name] = found;
    });
    return unusedKeys;
};
const findUnusedI18NextTranslations = async (source, filesToParse, componentFunctions = []) => {
    const unusedKeys = {};
    const { extractedResult, skippableKeys } = await getI18NextKeysInCode(filesToParse, componentFunctions);
    const extractedResultSet = new Set(extractedResult.map(({ key, namespace }) => namespace ? `${namespace}.${key}` : key));
    source.forEach(({ name, content }) => {
        const keysInSource = Object.keys(content);
        const found = [];
        for (const keyInSource of keysInSource) {
            const isSkippable = skippableKeys.find((skippableKey) => {
                return keyInSource.includes(skippableKey);
            });
            if (isSkippable !== undefined) {
                continue;
            }
            // find the file name
            const [fileName] = (name.split(path_1.default.sep).pop() ?? '').split('.');
            if (!extractedResultSet.has(`${fileName}.${keyInSource}`) &&
                !extractedResultSet.has(keyInSource)) {
                found.push(keyInSource);
            }
        }
        unusedKeys[name] = found;
    });
    return unusedKeys;
};
const findUnusedNextIntlTranslations = async (translationFiles, filesToParse) => {
    const unusedKeys = {};
    const extracted = (0, nextIntlSrcParser_1.extract)(filesToParse);
    const dynamicNamespaces = extracted.flatMap((namespace) => {
        if (namespace.meta.dynamic) {
            return [namespace.key];
        }
        return [];
    });
    const extractedResultSet = new Set(extracted.flatMap((namespace) => {
        if (!namespace.meta.dynamic) {
            return [namespace.key];
        }
        return [];
    }));
    translationFiles.forEach(({ name, content }) => {
        const keysInSource = Object.keys(content);
        const found = [];
        for (const keyInSource of keysInSource) {
            // Check if key is part of a dynamic namespace
            // Skip the key if it is part of the dynamic namespace
            const isDynamicNamespace = dynamicNamespaces.find((dynamicNamespace) => {
                const keyInSourceNamespaces = keyInSource.split('.');
                return dynamicNamespace.split('.').every((namePart, index) => {
                    return namePart === keyInSourceNamespaces[index];
                });
            });
            if (isDynamicNamespace) {
                continue;
            }
            if (!extractedResultSet.has(keyInSource)) {
                found.push(keyInSource);
            }
        }
        unusedKeys[name] = found;
    });
    return unusedKeys;
};
const checkUndefinedKeys = async (source, filesToParse, options = {
    format: 'react-intl',
    checks: [],
}, componentFunctions = []) => {
    if (!options.format || !ParseFormats.includes(options.format)) {
        return undefined;
    }
    if (!options.checks || !options.checks.includes('undefined')) {
        return undefined;
    }
    if (options.format === 'react-intl') {
        return findUndefinedReactIntlKeys(source, filesToParse);
    }
    else if (options.format === 'i18next') {
        return findUndefinedI18NextKeys(source, filesToParse, componentFunctions);
    }
    else if (options.format === 'next-intl') {
        return findUndefinedNextIntlKeys(source, filesToParse);
    }
};
exports.checkUndefinedKeys = checkUndefinedKeys;
const findUndefinedReactIntlKeys = async (translationFiles, filesToParse) => {
    const sourceKeys = new Set(translationFiles.flatMap(({ content }) => {
        return Object.keys(content);
    }));
    const extractedResult = await (0, cli_lib_1.extract)(filesToParse, {
        extractSourceLocation: true,
    });
    const undefinedKeys = {};
    Object.entries(JSON.parse(extractedResult)).forEach(([key, meta]) => {
        if (!sourceKeys.has(key)) {
            const data = meta;
            if (!('file' in data) || typeof data.file !== 'string') {
                return;
            }
            const file = path_1.default.normalize(data.file);
            if (!undefinedKeys[file]) {
                undefinedKeys[file] = [];
            }
            undefinedKeys[file].push(key);
        }
    });
    return undefinedKeys;
};
const findUndefinedI18NextKeys = async (source, filesToParse, componentFunctions = []) => {
    const { extractedResult, skippableKeys } = await getI18NextKeysInCode(filesToParse, componentFunctions);
    const sourceKeys = new Set(source.flatMap(({ content }) => {
        return Object.keys(content);
    }));
    const undefinedKeys = {};
    extractedResult.forEach(({ file, key }) => {
        const isSkippable = skippableKeys.find((skippableKey) => {
            return key.includes(skippableKey);
        });
        if (isSkippable === undefined && !sourceKeys.has(key)) {
            if (!undefinedKeys[file]) {
                undefinedKeys[file] = [];
            }
            undefinedKeys[file].push(key);
        }
    });
    return undefinedKeys;
};
const findUndefinedNextIntlKeys = async (translationFiles, filesToParse) => {
    const sourceKeys = new Set(translationFiles.flatMap(({ content }) => {
        return Object.keys(content);
    }));
    const extractedResult = (0, nextIntlSrcParser_1.extract)(filesToParse);
    const undefinedKeys = {};
    extractedResult.forEach(({ key, meta }) => {
        if (!meta.dynamic && !sourceKeys.has(key)) {
            const file = meta.file;
            if (!undefinedKeys[file]) {
                undefinedKeys[file] = [];
            }
            undefinedKeys[file].push(key);
        }
    });
    return undefinedKeys;
};
const isRecord = (data) => {
    return (typeof data === 'object' &&
        !Array.isArray(data) &&
        data !== null &&
        data !== undefined);
};
const getI18NextKeysInCode = async (filesToParse, componentFunctions = []) => {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const { transform } = await import('i18next-parser');
    const i18nextParser = new transform({
        lexers: {
            jsx: [
                {
                    lexer: 'JsxLexer',
                    componentFunctions: componentFunctions.concat(['Trans']),
                },
            ],
            tsx: [
                {
                    lexer: 'JsxLexer',
                    componentFunctions: componentFunctions.concat(['Trans']),
                },
            ],
        },
    });
    // Skip any parsed keys that have the `returnObjects` property set to true
    // As these are used dynamically, they will be skipped to prevent
    // these keys from being marked as unused.
    const extractedResult = [];
    const skippableKeys = [];
    filesToParse.forEach((file) => {
        const rawContent = fs_1.default.readFileSync(file, 'utf-8');
        const entries = i18nextParser.parser.parse(rawContent, file);
        // Intermediate solution to retrieve all keys from the parser.
        // This will be built out to also include the namespace and check
        // the key against the namespace corresponding file.
        // The current implementation considers the key as used no matter the namespace.
        for (const entry of entries) {
            // check for namespace, i.e. `namespace:some.key`
            const [namespace, ...keyParts] = entry.key.split(':');
            // If there is a namespace make sure to assign the namespace
            // and update the key name
            // Ensure that the assumed key is not the default value
            if (keyParts.length > 0 && entry.key !== entry.defaultValue) {
                entry.namespace = namespace;
                // rebuild the key without the namespace
                entry.key = keyParts.join(':');
            }
            if (entry.returnObjects) {
                skippableKeys.push(entry.key);
            }
            else {
                extractedResult.push({
                    file,
                    key: entry.key,
                    namespace: entry.namespace,
                });
            }
        }
    });
    return { extractedResult, skippableKeys };
};
const filterKeys = (content, keysToIgnore = []) => {
    if (keysToIgnore.length > 0) {
        return Object.entries(content).reduce((acc, [key, value]) => {
            if (keysToIgnore.find((ignoreKey) => {
                if (ignoreKey.endsWith('*')) {
                    return key.includes(ignoreKey.slice(0, ignoreKey.length - 1));
                }
                return ignoreKey === key;
            })) {
                return acc;
            }
            acc[key] = value;
            return acc;
        }, {});
    }
    return content;
};
function _flatten(object, prefix = null, result = {}) {
    for (const key in object) {
        const propName = prefix ? `${prefix}.${key}` : key;
        const data = object[key];
        if (isRecord(data)) {
            _flatten(data, propName, result);
        }
        else {
            result[propName] = data;
        }
    }
    return result;
}
